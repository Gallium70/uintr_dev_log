# RISC-V 外部中断控制器

PLIC 是目前 RISC-V 平台上使用较多的中断控制器设计，可以将中断线上的信号组合发送到处理器核的中断寄存器中。在 PLIC 中，中断源是某个外设，而目标是一个“上下文”，即某个处理器核的某个特权级，在寄存器层面即为 xip.XEIP 位，其中 x 为特权级代号。

尽管在实现了用户态中断寄存器，并在 PLIC 中添加用户态对应的上下文之后，即可在用户态处理外部中断，但在系统层面允许多个应用（包括内核）分别处理多个外设的中断却存在一定的困难。在触发中断后，应用需要执行领取-完成操作（claim-complete），即从 PLIC 中与当前上下文对应的 MMIO 地址中读出中断源编号，读出后 PLIC 会屏蔽该中断源的中断信号；应用在处理完成后需要将中断源编号写入对应的地址，随后 PLIC 会解除对中断信号的屏蔽。完成操作要求写入的中断源编号必须在写入的 MMIO 地址对应的上下文中已经使能，否则会忽略这次完成操作。

目前 rCore-N 将整个 PLIC 对应的 MMIO 地址段完全映射到用户态地址空间中，在调度应用时在对应的处理器核的用户态对应的 PLIC 上下文上使能或屏蔽该应用申请的外设，同时由应用读取当前自身所处的处理器核编号，计算出对应的上下文地址，执行领取-完成操作。这种操作逻辑大体上可以满足用户态应用处理外部中断的需求，但在一个细节处可能出问题。在应用读取处理器核编号到计算出上下文地址并访问 PLIC 这段过程中间，应用可能被抢占调度到其他核上运行，导致应用访问 PLIC 的上下文地址与其实际所在的上下文不符。对于完成过程，这会导致 PLIC 忽略本次操作，而没有解除对相应中断源的屏蔽，应用之后再也无法收到该中断源产生的中断。

一个补救措施是采用类似 LR-SC 循环的方法，在写入 PLIC 之前和之后分别读取当前核编号，若两次不符则重新写入 PLIC 。由于 PLIC 会忽略没有使能相应中断的上下文上的完成操作，错误的完成操作不会导致副作用，但仍然可能有极微小的概率，应用在读取核编号——完成——再次读取核编号中经历两次调度，并在第二次调度时回到先前的核上，使该补救措施失效。更进一步的方案可以采用 Linux 内核中的可重启序列（Restartable Sequence, rseq），由用户程序划定一段临界区并告知内核，当发生（调度等）中断进入内核时，内核检测用户程序是否处于该临界区内，若是则将用户程序指针指向一个退出点，由用户处理被打断的操作。这一方案要求临界区必须为一段连续的地址，因而在临界区中执行函数调用可能存在困难。

在原理上更合适的方案是，内核仅分配一个虚拟地址页给用户（而非全部的 PLIC 地址段）作为一个虚拟的 PLIC 上下文，在切换运行核时修改该虚拟地址和实际 PLIC 上下文的物理地址的映射（PLIC 的上下文地址是对齐到 4KB 边界的）。该方案的问题在于修改内存映射可能增加调度切换的开销，影响性能。本质上 PLIC 在设计时并未完全考虑用户态中断的场景，因而软件设计不得不更复杂一些。

与外设-处理器间的数据通路相比，单独的中断线可以视作一种带外（Out-of-Band）信号，而与之相对的，消息信号中断（Message Signaled Interrupt, MSI）是一种带内（In-Band）信号，外设通过在数据通路上向特定的 MMIO 地址写入数据向处理器传递中断信息，不需要额外的中断线。写入的数据通常会发送到中断控制器，后者再产生中断信号发送到处理器核中。PCIE 设备常采用msi产生中断。在 RISC-V 架构中，先进中断架构（Advanced Interrupt Archetecture, AIA）规范中定义了 IMSIC 中断控制器用于接收处理 MSI 。IMSIC 和硬件线程一比一组合，并为每个特权级保留了单独的中断文件（interrupt file）。在虚拟化场景下，IMSIC可以有多个虚拟机的中断文件，这可以作为之后为用户态中断支持MSI的设计参考。

与IMSIC不同，AIA中没有提供PLIC/APLIC的硬件虚拟化实现，而建议采用陷入-模拟（trap and emulate）的方案，主要理由是高性能外设大概率采用MSI而非中断线。
