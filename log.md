# 用户态中断 开发日志

## 2023.3.16

测试FIFO+轮询的乒乓驱动，每次发一定数量的字符，再等待收到同样数量的字符，再进行下一轮操作。

行为比较怪异：如果每轮发送和接收的不超过8个字符，那么不会出现错误，且吞吐量基本线性增长，最高可达400K；

一旦超过8个，就会出现丢数据的情况。仿佛收发的FIFO深度只有8，但几份数据手册上都写的是16。

尝试了若干参数组合，现象如下：

1. 每次尝试发送的字符越多，出现错误越早。
2. 波特率越低，出现错误越早。
3. 系统的调度周期会影响出错位置的离散度（固定每周期收发12字符）：

| 调度周期 | 首次出错位置分布 |
|- | - |
| 0.01s | 300 - 2.5k |
| 0.1s | 800 - 50k |
| 1s | 30 - 400k |

4. 在驱动里限制发送（每次都等到 LCR.THRE 有效再发送），相当于禁用发送 FIFO ，没什么效果，还是会出错。

目前看起来影响比较大的可能是调度，之后也要看一下生成的IP核的硬件代码，确认一下FIFO深度到底是不是16。


## 2022.3.9

在fpga板上测试，发现两个问题：

1. 即使是轮询模式，收发也不对等，收的数量仅有发的1/3左右，且效率低于之前的版本
2. 中断模式收不到数据

这两个问题与异步驱动无关，怀疑与PAC库有关。再次梳理初始化流程，加入了更多的寄存器复位操作，重新调整缓冲区参数后，轮询模式效率有所提升，但仍然低于之前。

关于中断，发现是PAC库对于寄存器提供write和modify两个参数，前者会覆盖整个寄存器的内容（类似csrw指令），后者只会更改指定的位域（类似csrc/csrs）。之前用write操作16550的IER寄存器，会在开启读取中断的同时关掉写入中断，反之亦然。改为modify之后可以正常收发，但效率同样较低。

中断模式修改后，异步驱动可以收发数据，但吞吐量异常低，仅有1KB/s左右，原因仍在排查。

下周：

先做乒乓收发，解决轮询和中断丢数据问题，低于5%，确定三个模式都正常工作，然后再考虑异步驱动的效率

日志放进仓库

## 2022.3.2

异步驱动

先前的故障：基于用户态中断的异步串口驱动只发不收，发的字节数量恰好为设定的软件缓冲区的大小
 
分析：从收发字节数量入手，推测可能是读的异步任务跑飞了，对端把缓冲区塞满之后就无法工作。

插入调试输出，观察到在驱动收到中断后，读/写任务的waker丢失，将缓冲区调小之后很快就没有输出，确认程序将驱动的缓冲区填满一次之后就停止工作。
 
推测故障原因：

之前在测试负载中，构造了一个executor，往其中加入了一个读任务和一个写任务，当这两个任务均运行完成（自身任务的缓冲区存满或耗尽）时，再向executor加入一个读任务和写任务。但如果收发速率稍微不均衡，可能在两边读任务都先跑完，而写任务将对端缓冲区填满之后，不会再消耗，两个测试任务出现死锁，直到测试超时。
 
修改方法：

读任务和写任务的创建解耦，目前为读写创建了两个executor
 
修改后的效果

写入数量远超驱动缓冲区，读写任务会持续运行到测试程序超时。接收量仍然偏少，推测在qemu中设备后端的缓冲区较大，且处理速度较快，写入总会完成，读任务可能被饥饿。后续在硬件平台上测试。
